# ShellSort

## 算法描述

希尔排序是一种基于[插入排序](InsertionSort.md)的快速的排序算法 。
对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端 。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要$N- 1$次移动 。   

希尔排序为了加快速度简单地改进了插入排序
- 交换不相邻的元素以对数组的局部进行排序
- 并最终用插入排序将局部有序的数组排序 。  

希尔排序的思想

- 使数组中任意间隔为$h$的元素都是有序的 。 这样的数组被称为$h$有序数组 。 
- 换句话说， 一个$h$有序数组就是$h$个互相独立的有序数组编织在一起组成的一个数组。在进行排序时，如果$h$很大，我们就能将元素移动到很远的地方，为实现更小的$h$有序创造方便 。 用这种方式，对于任意以$1$结尾的$h$序列，我们都能够将数组排序 。 这就是希尔排序 。  

实现希尔排序的一种方法是对于每个$h$ , 用插入排序将$h$个子数组独立地排序。但因为子数组是相互独立的， 一个更简单的方法是在$h$－子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格） 。只需要在插入排序的代码中将移动元素的距离由$1$改为$h$即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。

希尔排序更高效的原因是它权衡了子数组的规模和有序性。
-  排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。
-  数组部分有序的程度取决于递增序列的选择。

透彻理解希尔排序的性能至今仍然是一项挑战。

实际上，下面实现的算法是我们唯一无法准确描述其对于乱序的数组的性能特征的排序方法。

## 实现

```C++
// ShellSort
class Solution {
public:
    vector<int> sortArray(vector<int>& nums){
		int h = 1;
        while(h < nums.size()/3){
            h = 3*h + 1;
        }
        
        while(h >= 1){
            for(auto i = h; i != nums.size(); i++){
                for(auto j = i; j >= h && nums[j] < nums[j-h]; j -= h)
                    swap(nums[j], nums[j-h]);
            }
            
            h = h/3;
        }
        
        return nums;
    }
};
```

> leetcode通过了,时间复杂度可见小于$O(n^2)$