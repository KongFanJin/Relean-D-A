# 哈夫曼树

带权路径长度  
- 从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积  

树的带权路径长度 ($WPL=\sum_{i=-1}^{n}w_il_i$)
- 树中所有叶结点的带权路径长度之和  

哈夫曼树
- 带权路径长度 (WPL) 最小的二叉树 

举例
<img src="images/Tree/Huffman/哈夫曼树 01.png" alt="哈夫曼树 01" style="zoom:67%;" />

- `WPL(a) = 7x2 + 5x2 + 2x2 + 4x2 = 36`   
- `WPL(b) = 4x2 + 7x3 + 5x3 + 2x1 = 46`
- `WPL(c) = 7x1 + 5x2 + 2x3 + 4x3 = 35`     
  - `WPL(c)`最小

# 构造哈夫曼树

构造过程
<img src="images/Tree/Huffman/哈夫曼树 02.png" alt="哈夫曼树 02" style="zoom:60%;" />
- 1) 将这 `n` 个结点分别作为` n `棵仅含一个结点的二叉树 ,构成森林 `F`
- 2) 构造一个新结点，从`F`中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。
- 3) 从`F`中删除刚才选出的两棵树，同时将新得到的树加`F`中  
- 重复步骤 2) 和 3) ，直至`F`中只剩下一棵树为止。  

哈夫曼树具有如下特点
- 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。  
- 构造过程中共新建了 `n-1`个结点（双分支结点），因此哈夫曼树的结点总数为 `2n-1`
- 每次构造都选择`2`棵树作为新结点的孩子 ,因此哈夫曼树中不存在度为`1`的结点

# 哈夫曼编码

可将字符的编码解释为从根至该字符的路径上边标记的序列，
- 标记为 0 表示“转向左孩子”，
- 标记为 1 表示“转向右孩子

如图所示为一个由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数
<img src="images/Tree/Huffman/哈夫曼树 03.png" alt="哈夫曼树 03" style="zoom:60%;" />

`WPL = 1x45 + 3x(13 + 12 + 16) + 4x(5 + 9) = 224 `

# 补充 
- 0 和 1 究竟是表示左子树还是右子树没有明确规定。
- 左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树==并不唯一==，但各哈夫曼树的带权路径长度 WPL 相同且为最优。
- 此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但 WPL 必然相同且是最优的