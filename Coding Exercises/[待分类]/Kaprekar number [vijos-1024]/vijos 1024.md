[卡布列克圆舞曲 - Vijos](https://vijos.org/p/1024)

[卡布列克常数 运用string类](https://blog.csdn.net/oneplus123/article/details/84758396)

# 描述

卡布列克是一位数学家，他在研究数字时发现：

- 任意一个不是用完全相同数字组成的四位数，如果对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数，差不够四位数时补零
- 类推下去，最后将变成一个固定的数：`6174`，这就是卡布列克常数。

例如:对于四位数`4321`：
```
4321-1234=3087
8730-378=8352
8532-2358=6174
7641-1467=6174
```
如果`K`位数也照此办理，它们不是变成一个数，而是在几个数字之间形成循环，称作卡布列克圆舞曲。

例如:对于五位数`54321`：
```
54321-12345=41976
97641-14679=82962
98622-22689=75933
97533-33579=63954
96543-34569=61974
97641-14679=82962
```
我们把`82962 75933 63954 61974`称作循环节，即卡布列克圆舞曲。

# 格式

## 输入格式

文件包含若干行，每行为一个待求“卡布列克圆舞曲”的起始整数（小于`maxlongint`）

## 输出格式

每行为对应整数的循环节，数据之间用空格隔开。

# 样例1

样例输入1

```data
4321
54321
```

样例输出1

```data
6174
82962 75933 63954 61974
```

# 实现

```C++
#include <algorithm>
#include <iostream>
#include <sstream>

using namespace std;

int main() {
    string s;
    cin >> s;
    
    int maxx, minn;

    while (s != "6174") {
        stringstream s1, s2, s3;

        // sort对string类型数据进行字符串内排序,升序, s变为最大值
        sort(s.begin(), s.end());
        s1 << s;
        s1 >> minn;

        // reverse将string反转, s变为最小值
        reverse(s.begin(), s.end());
        s2 << s;
        s2 >> maxx;

        int num = maxx - minn;

        cout << maxx << " - " << minn << " = " << num << "\n";

        s3 << num;
        s3 >> s;

        for (int i = s.size(); i < 4; i++)
            s += '0';
    }

    return 0;
}
```

> 借助字符串流,实现`string`与`int`的转换